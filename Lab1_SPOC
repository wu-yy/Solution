
描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么？
识別4个特权级(或特权层) ，0级到3级。数值越大特权越小。一般用把系统内核放在0级，系统的其他服务程序位于1、2级，3级则是应用软件。一般情况下代码都在自己的级别下做自己的工作，同一级别之间可以相互访问，而一般是不允许不同级别的代码间随意访问的。但有时候不同级别的程序之间一定要访问，比如系统的接口函数等，必须能够使得应用程序能够随意调用。于是Intel将代码分为：
1.非一致码：受到隔离的代码，只能在同一级别间相互访问
2.一致码：不受到隔离的就是，允许被同等级或低等级代码调用。

DPL：描述符特权
存在80386 INTERRUPT GATE 80386 TRAP GATE
存储在描述符中的权限位，用于描述代码的所属的特权等级，也就是代码本身真正的特权级。一个程序可以使用多个段(Data，Code，Stack)也可以只用一个code段等。正常的情况下，当程序的环境建立好后，段描述符都不需要改变——当然DPL也不需要改变，因此每个段的DPL值是固定。
RPL：请求特权级RPL(Request Privilege Level)
RPL保存在选择子的最低两位。RPL说明的是进程对段访问的请求权限，意思是当前进程想要的请求权限。RPL的值由程序员自己来自由的设置，并不一定RPL>=CPL，但是当RPL<CPL时，实际起作用的就是CPL了，因为访问时的特权检查是判断：EPL=max(RPL,CPL)<=DPL是否成立，所以RPL可以看成是每次访问时的附加限制，RPL=0时附加限制最小，RPL=3时附加限制最大。所以你不要想通过来随便设置一个rpl来访问一个比cpl更内层的段。
 
因为你不可能得到比自己更高的权限，你申请的权限一定要比你实际权限低才能通过CPU的审查，才能对你放行。所以实际上RPL的作用是程序员可以把自己的程序降级运行——有些时候为了更好的安全性,程序可以在适当的时机把自身降低权限（RPL设成更大的值）。

CPL：当前任务特权
表示当前正在执行的代码所处的特权级。CPL保存在CS中的最低两位，是针对CS而言的。当选择子成功装入CS寄存器后，相应的选择子中的RPL就变成了CPL。因为它的位置变了，已经被装入到CS寄存器中了，所表达的意思也发生了变——原来的要求等级已经得到了满足，就是当前自己的等级。
 
选择子可以有许多个，因此RPL也就有许多个。而CPL就不同了，正在执行的代码在某一时刻就只有这个值唯一的代表程序的CPL.
 
另外特别要求CS与SS的特权级必须保持一致。对于装入DS、ES、FS、GS的选择子INTEL没有给它们起什么特殊的名称，我也不知道应该叫它们什么，也许可以仍然称它为RPL。

2.比较不同特权级的中断切换时的堆栈变化差别：
处理器通过CPL,DPL,RPL来进行特权级管理
堆栈的使用：
1. 不同的特权等级使用不同的堆栈，只有使用调用门的转移才能实现堆栈的切换。所以，利用call和jmp直接转移，对于非一致性代码，只能同级转移（没有堆栈切换）；对于一致性代码，cpl必须在转移过程中保持不变（这样也不存在堆栈切换）。
2. 如果用jmp+调用门转移，cpl必须等于目标代码段的dpl。因为jmp也无法实现堆栈切换。
3. 总结，只有call+调用门才能实现堆栈切换，这是理解这些乱七八糟cpl与dpl规则的关键。
4. call只能实现低特权级到高特权级的转移
5. 如果要堆栈切换（从低特权堆栈切换到高特权堆栈），则必须把TSS准备好。
5. 高特权级到低特权级，必须用retf指令
